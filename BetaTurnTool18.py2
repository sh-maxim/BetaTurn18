#!/usr/bin/env python

# ########
# Platform
# ########
# 
# Supported on Unix/Mac/Windows with Python 2

# #########
# Execution
# #########
# This program is written for Python 2 which is more common.
# Please make sure you are running this program with Python 2, NOT Python 3.
# 'python' from your terminal needs to link to Python 2, NOT Python 3.
# 
# For execution from a terminal, you may try:
# 
# Unix/Mac/Windows:
# -----------------
# python BetaTurnTool18.py2
# python2 BetaTurnTool18.py2
#
# Unix/Mac:
# ---------
# /usr/bin/python BetaTurnTool18.py2
# /usr/bin/python2 BetaTurnTool18.py2
# /usr/bin/env python BetaTurnTool18.py2
# /usr/bin/env python2 BetaTurnTool18.py2
#
# For Shebang (Hashbang) in Unix/Mac:
# -----------------------------------
# Make sure in the top line 'python' links to Python 2 and NOT Python 3
# If Python 2 is linked with python2, please modify the top line to "#!/usr/bin/env python2"
#
# Windows:
# --------
# C:\Python\python.exe BetaTurnTool18.py2

# #######
# License
# #######
# Copyright (c) 2018-2019, Maxim Shapovalov (1,2), Slobodan Vucetic (2), Roland L. Dunbrack, Jr. (1,^)
# All rights reserved.
# 
# (1): Fox Chase Cancer Center, 333 Cottman Avenue, Philadelphia PA 19111, USA
# (2): Temple University, 1801 N Broad Street, Philadelphia PA 19122, USA
# (^): Corresponding Author, Roland dot Dunbrack at fccc dot edu
# 
# BSD 3-Clause License
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
# 
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# 
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE

import sys

global glob_operating_system; glob_operating_system = 'unix'
global glob_operating_system_full; glob_operating_system_full = 'Unix'

#detection of operating system family
_platform = sys.platform.lower()
if "linux" in _platform or "unix" in _platform:
    glob_operating_system = 'unix'
    glob_operating_system_full = 'Unix'
elif "darwin" in _platform or "mac" in _platform:
    glob_operating_system = 'mac'
    glob_operating_system_full = 'Mac OS'
elif "win" in _platform:
    glob_operating_system = 'win'
    glob_operating_system_full = 'Windows'

#automatic installation of required python packages in Unix/Mac/Windows
_required_packages = [['Bio','biopython'], ['numpy','numpy']]
for _package in _required_packages:
    try:
        exec(_package[0] + " = __import__(_package[0])")
    except ImportError as e:
        try:
            print ".................................................................................."
            print "..... Your operating system family is detected as \'%s\'" % glob_operating_system_full
            print "..... Automatically installing required python2 module, \'%s\'" % _package[1]
            import pip
            try:
                from pip import main as pipmain
                print "..... Older version of python module installer, \'pip\' is detected"
            except ImportError:
                from pip._internal import main as pipmain
                print "..... Newer version of python module installer, \'pip\' is detected"
            print ".................................................................................."
            if glob_operating_system == 'win':
                _user_is_admin = False
                try:
                    import ctypes
                    _user_is_admin = (ctypes.windll.shell32.IsUserAnAdmin() != 0)
                except:
                    print "..... Could not determine for sure whether you ARE or ARE NOT an administrator on this computer."
                    print "..... Installation will proceed assuming you are NOT an administrator."
                if _user_is_admin == True:
                    print "..... You ARE an administrator of this computer."
                    print "..... Therefore trying to install the module systemwide"
                    print ".................................................................................."
                    pipmain(['install', _package[1]])
                else:
                    print "..... You are NOT an administrator of this computer."
                    print "..... Therefore trying to install the module locally in your Documents directory"
                    print ".................................................................................."
                    pipmain(['install', '--user', _package[1]])
            elif glob_operating_system in ['unix', 'mac']:
                import os
                if os.geteuid() == 0:
                    print "..... You HAVE root previliges."
                    print "..... Therefore trying to install the module systemwide"
                    print ".................................................................................."
                    pipmain(['install', _package[1]])
                else:
                    print "..... You do NOT have root previliges."
                    print "..... Therefore trying to install the module locally in your home directory"
                    print ".................................................................................."
                    pipmain(['install', '--user', _package[1]])
            print ".................................................................................."
            exec(_package[0] + " = __import__(_package[0])")
        except Exception as _e:
            print "*****************************************************"
            print "*** The program automatically attempted to install a required python2 module, \'%s\'." % _package[1]
            print "*** "
            print "*** (1) If the module installation was successful, run this program again."
            print "*** (2) If (1) was unsuccesful, run this program again with root previliges (sudo)."
            print "*** (3) If both (1) and (2) are unsuccessful, please install a required python2 module \'%s\' yourself" % _package[1]
            print "***     by issuing one of the following commands and then try again:"
            print "    "
            print "             apt-get install python-%s" % _package[1]
            print "        sudo apt-get install python-%s" % _package[1]
            print "             pip2 install %s" % _package[1]
            print "        sudo pip2 install %s" % _package[1]
            print "             pip  install %s" % _package[1]
            print "        sudo pip  install %s" % _package[1]
            print "    "
            print "    (4) If all three (1), (2) and (3) are unsuccesful, please review the following technical details:"
            print "    "
            print "        Exception details:"
            print "        ~~~~~~~~~~~~~~~~~~"
            print "        %s" % _e
            print "        (this error message might be incorret -- please try again)"
            exit(1)

#by this line all required python libraries must have been already installed
import os
import csv
import math
import warnings
import argparse
import re

#biopython library components
import Bio.PDB
import Bio.SeqIO
import Bio.pairwise2

#main entry point of the program
def main():
    #declaring global variables and setting their default values
    global glob_fpath_script; glob_fpath_script = os.path.realpath(__file__)
    global glob_fpath_script_dir; glob_fpath_script_dir = os.path.split(glob_fpath_script)[0]
    global glob_fPath_dssp_binary
    global glob_fPath_BetaTurnLib
    global glob_BetaTurnLib_version; glob_BetaTurnLib_version = '-1.-1.-1'
    global glob_bTurnLibListOfDict
    global glob_default_bturn_library_filename; glob_default_bturn_library_filename = r'BetaTurnLib18.txt'
    global glob_border_confidence_value; glob_border_confidence_value = 0.70
    global glob_max_L1Distance_betw_closestMedoid_sample_otherwise_Other
    #This maximum distance is equal to the mean plus 3 standard deviations of
    #12,711 distances between turns of one of 18 types (Other excluded) to
    #their cluster medoids, which is equal to 0.2359 in units of our distance metric
    #or 28.1 deg in units of the average angle equivalent of our metric.
    glob_max_L1Distance_betw_closestMedoid_sample_otherwise_Other =  0.052794243055754 + 3 * 0.061032309981708
    global CA1CA4_beta_turn_distance_cutoff
    global global_SkipProcessingOfAlternativeConformations 
    #This option is now disabled in official arguments, it is kept here in code, just in case, it is always False
    global_SkipProcessingOfAlternativeConformations = False


    #For macOS only: for newer versions of DSSP need to specify a location for dynamically linked libraries of Boost library
    if glob_operating_system == 'mac':
        os.environ["DYLD_FALLBACK_LIBRARY_PATH"] = os.path.join(glob_fpath_script_dir, 'DSSP', 'Lib_macOS')


    #setting up expected input arguments
    myArgParser = argparse.ArgumentParser(add_help=False)

    myArgParser.add_argument("-i", "--input", help='for example, -i abcd.cif or --input abcd.pdb')
    myArgParser.add_argument("-o", "--output", default="file_output_is_disabled")
    myArgParser.add_argument("-noG", "--exclude-all-3-10-helix", action='store_true')
    myArgParser.add_argument("-allG", "--include-all-3-10-helix", action='store_true')

    myArgParser.add_argument("-noOther", "--exclude-other-group-from-turn-assignment", action='store_true')
    myArgParser.add_argument("-Ca1Ca4", "--Ca1Ca4-distance-cutoff", default=7.0)

    myArgParser.add_argument("--quiet", action='store_true')
    myArgParser.add_argument("--no-comments", action='store_true')
    myArgParser.add_argument("--no-table-format", action='store_true')
    myArgParser.add_argument("--no-seq-format", action='store_true')
    myArgParser.add_argument("--yes-singleline-format", action='store_true')
    myArgParser.add_argument("-mode", "--report-closest-mode-torsions", action='store_true')
    myArgParser.add_argument("-medoid", "--report-closest-medoid-torsions", action='store_true')
    myArgParser.add_argument("-everything", "--print-any-4-res-segments", action='store_true')
    myArgParser.add_argument("--yes-2nd-turn-alternative-for-other-group", action='store_true')

    myArgParser.add_argument("--library", default=glob_default_bturn_library_filename)
    myArgParser.add_argument("--dssp", default='undefined')
    myArgParser.add_argument("-h", "--help", action='store_true')


    #actual parsing of input arguments
    args = myArgParser.parse_args()
    #when no arguments are provided or help flag is provided, the program has to give the full help information and quit
    if len(sys.argv) <= 1:
        args.help = True

    if args.dssp == 'undefined':
        if glob_operating_system == 'win':
            glob_fPath_dssp_binary = r'dssp_win'
        elif glob_operating_system == 'unix':
            glob_fPath_dssp_binary = r'dssp_unix'
        elif glob_operating_system == 'mac':
            glob_fPath_dssp_binary = r'dssp_mac'
    else:
        glob_fPath_dssp_binary = args.dssp

    #compiling full-path filename for DSSP binary, input could be simple filename, relative filename and full path
    if os.path.isfile(os.path.join(glob_fpath_script_dir, 'DSSP', glob_fPath_dssp_binary)):
        #if the last parameter is full path, path.join function return the last parameter
        glob_fPath_dssp_binary = os.path.join(glob_fpath_script_dir, 'DSSP', glob_fPath_dssp_binary)
    elif os.path.isfile(os.path.join(os.getcwd(), glob_fPath_dssp_binary)):
        glob_fPath_dssp_binary = os.path.join(os.getcwd(), glob_fPath_dssp_binary)
    else:
        glob_fPath_dssp_binary = glob_fPath_dssp_binary

    if args.help or (not args.quiet and not args.no_comments):
        PrintProgramInformation()

    #if the second parameter is full path, path.join function return the second parameter
    glob_fPath_BetaTurnLib = os.path.join(glob_fpath_script_dir, 'BetaTurnLib18', args.library)
    #load beta-turn types with their characteristics from included external file
    glob_bTurnLibListOfDict = ReadBetaTurnLibrary(glob_fPath_BetaTurnLib, args)
    Extend_bTurnLibListOfDict_WithAdditInfo(glob_bTurnLibListOfDict)

    if args.help:
        print '# '
        myArgParser.print_help()

    if args.help:
        print '# '
        PrintProgramUsage()

    if args.help or (not args.quiet and not args.no_comments):
        Print_bTurns_Information()
        Print_bturn_type_confidence_Information()

    if args.help or (not args.quiet and not args.no_comments):
        print '# '
        if args.exclude_other_group_from_turn_assignment:
            print "# Other group is exclude from the beta-turn assignment."
            print "# The closest turn type to a sample turn is assigned from only 18 types."
            print "# If the closest turn is too far way, it is still reported and no Other group is reported."
            print "# ========================================================================================"
        else:
            print "# By default, Other group is included into the beta-turn assignment."
            print "# The closest turn type to a sample turn is assigned from 18 types and Other group."
            print "# If the closest turn is too far way, Other group is reported."
            print "# In such case the sample turn does not fit any of 18 turn types."
            print "# ================================================================================="

    CA1CA4_beta_turn_distance_cutoff = float(args.Ca1Ca4_distance_cutoff)
    if args.help or (not args.quiet and not args.no_comments):
        print "# "
        print "# CA(1)-CA(4) distance threshold = %6.3f A is enforced in a beta-turn definition" % CA1CA4_beta_turn_distance_cutoff
        print "# ==============================================================================="

    #process the first model in PDB / CIF file with all its chains
    how_to_process_3_helix = 'default_allow_isolated_GGG'
    if args.exclude_all_3_10_helix == True:
        how_to_process_3_helix = 'exclude_all_G'
    if args.include_all_3_10_helix == True:
        how_to_process_3_helix = 'include_all_G'
    if args.help or (not args.quiet and not args.no_comments):
        print "# "
        if how_to_process_3_helix == 'default_allow_isolated_GGG':
            print "# The default allows the 2nd and 3rd beta-turn residues in an isolated 3-10 helix"
            print "# which is not adjacent to an alpha helix (H) on either side."
            print "# For example, CGGGC or EGGGE are allowed while HGGGC or CGGGH or CGGGGC are not analyzed for turns."
            print "# =================================================================================================="
        elif how_to_process_3_helix == 'exclude_all_G':
            print "# The optional argument flag %s is enforced" % '--exclude-all-3-10-helix'
            print "# The 2nd and 3rd beta-turn residues are restricted in a 3-10 helix of any length."
            print "# ========================================================================================"
        elif how_to_process_3_helix == 'include_all_G':
            print "# The optional argument flag %s is enforced" % '--include-all-3-10-helix'
            print "# The 2nd and 3rd beta-turn residues are allowed in a 3-10 helix of any length."
            print "# ====================================================================================="

    if args.help:
        #quiting since no arguments provided
        return

    #post arg parsing processing
    if args.exclude_all_3_10_helix == True and args.include_all_3_10_helix == True:
        raise Exception('Argument error: --exclude-all-3-10-helix and --include-all-3-10-helix are not allowed at the same time')

    if args.input == None:
        print('Argument error: An input protein structure is required specified with -i or --input')
        return

    #as precautionary step not to use this threshold by a mistake
    if args.exclude_other_group_from_turn_assignment:
        del glob_max_L1Distance_betw_closestMedoid_sample_otherwise_Other

    fileNameStructure = args.input
    outputFilename = args.output
    #-----------------------
    #all arguments processed


    if not args.quiet and not args.no_comments:
        print "# "
        _tempString = "Input filename = %s" % (fileNameStructure)
        print "# %s" % _tempString
        print '# ' + '*' * len(_tempString)
        del _tempString

    if not args.quiet and not args.no_comments and not args.no_table_format:
        print "# "
        print "# Detected beta turns in a table format:"
        print "# --------------------------------------"

    if outputFilename not in ('file_output_is_disabled', None):
        outputfile = open(outputFilename, 'wt')
    else:
        outputfile = None

    ProcessOneModelWithAllChains(fileNameStructure, outputfile, how_to_process_3_helix, args)

    if outputfile != None:
        outputfile.close()

def ReadBetaTurnLibrary(_fPathBTurnClusterMedoidsFile, _args):
    global glob_BetaTurnLib_version;
    _bTurnLibListOfDict = []
    with open(_fPathBTurnClusterMedoidsFile, 'rt') as csvfile:
        cvsreader = csv.DictReader(csvfile, delimiter='\t', fieldnames=['no_by_size', 'cluster_size', 'frequency', 'bturn_name', 'prev_name', 'median_below_7A_ca1_ca4', 'mean_below_7A_ca1_ca4', 'median_any_ca1_ca4', 'mean_any_ca1_ca4', 'mode_omega2', 'mode_phi2', 'mode_psi2', 'mode_omega3', 'mode_phi3', 'mode_psi3', 'mode_omega4', 'mode_aa1', 'mode_aa2', 'mode_aa3', 'mode_aa4', 'mode_ss1', 'mode_ss2', 'mode_ss3', 'mode_ss4', 'mode_pdb_id', 'mode_chain_id', 'mode_res1_id', 'medoid_omega2', 'medoid_phi2', 'medoid_psi2', 'medoid_omega3', 'medoid_phi3', 'medoid_psi3', 'medoid_omega4', 'medoid_aa1', 'medoid_aa2', 'medoid_aa3', 'medoid_aa4', 'medoid_ss1', 'medoid_ss2', 'medoid_ss3', 'medoid_ss4', 'medoid_pdb_id', 'medoid_chain_id', 'medoid_res1_id'])
        for row in cvsreader:
            if row['no_by_size'][0] == '#' or row['no_by_size'] == 'no_by_size':
                if row['no_by_size'][0:10] == '# Version ':
                    glob_BetaTurnLib_version = row['no_by_size'].split()[2]
                continue
            elif row['no_by_size'] != 'total':
                if _args.exclude_other_group_from_turn_assignment and row['no_by_size'] == 'Other':
                    continue
                _bTurnLibListOfDict.append(row)
    return _bTurnLibListOfDict

def ProcessOneModelWithAllChains(_fileNameStructure, _outputfile, _how_to_process_3_helix, _args):
    #disabling annoying PDB warnings
    warnings.filterwarnings("ignore", message = '.*Chain .? is discontinuous.*')
    warnings.filterwarnings("ignore", message = '.*Could not assign element.*')
    warnings.filterwarnings("ignore", message = '.*Residue .? is discontinuous.*')
    warnings.filterwarnings("ignore", message = '.*no atoms read before TER record.*')
    warnings.filterwarnings("ignore", message = '.*Negative occupancy in one or more atoms.*')
    warnings.filterwarnings("ignore", message = '.*Used element.*with given element.*')
    warnings.filterwarnings("ignore", message = '.*Residue.*redefined at line.*')
    if '.cif' not in os.path.splitext(_fileNameStructure)[1].lower() and '.mmcif' not in os.path.splitext(_fileNameStructure)[1].lower():
        pdbParser = Bio.PDB.PDBParser(PERMISSIVE=1)
        proteinStruct = pdbParser.get_structure("my_pdb " + _fileNameStructure, _fileNameStructure)
    else:
        cifParser = Bio.PDB.MMCIFParser()
        proteinStruct = cifParser.get_structure("my_cif " + _fileNameStructure, _fileNameStructure)

    #take the first model from the input structure file
    _proteinModel = proteinStruct[0]
    #execute dssp installed on a local computer to assign secondary structure to input protein structure
    dssp_class = RunDsspAndStoreResultsInChainDictionary(_proteinModel, _fileNameStructure)

    #scan the current model and print all beta turns along with their clusters and ids
    ScanInputModelAndAllItsChainsForBetaTurnsAndTheirTypes(_proteinModel, dssp_class, _outputfile, _fileNameStructure, _how_to_process_3_helix, _args)

def RunDsspAndStoreResultsInChainDictionary(_proteinModel, _fileNameStructure):
    if '.cif' not in os.path.splitext(_fileNameStructure)[1].lower() and '.mmcif' not in os.path.splitext(_fileNameStructure)[1].lower():
        pass
    else:
        #new PDB file is created on fly from a structure model loaded from a cif file
        #it is required in order to run DSSP
        if float(Bio.__version__) < 1.72:
            import PDBIO_ver_1_72
            _pdbio_object = PDBIO_ver_1_72.PDBIO()
        else:
            _pdbio_object = Bio.PDB.PDBIO()
        _pdbio_object.set_structure(_proteinModel)
        #save pdb file generated on fly from cif into the current working directory
        _fileNameStructure = os.path.join(os.getcwd(), os.path.splitext(os.path.basename(_fileNameStructure))[0] + '_from_cif' + '.pdb')
        _pdbio_object.save(_fileNameStructure)

    try:
        #execute DSSP through biopython, however it requires a binary and runs it on the input PDB file
        _dssp_class = Bio.PDB.DSSP(_proteinModel, _fileNameStructure, dssp=glob_fPath_dssp_binary)
    except Exception as _exception:
        #problem with DSSP binary detected, figure out what is wrong and suggest a fix to the user
        print ""
        print "***** ERROR *********************************************************"
        if os.path.isfile(glob_fPath_dssp_binary):
            print "Cannot execute DSSP, \'%s\' in your operating system detected as '%s'." % (glob_fPath_dssp_binary, glob_operating_system_full)
            print ""
            print "Exact DSSP error message is '" + _exception.message + "'"
            print ""
            print "This Software relies on DSSP, a secondary structure assignment tool."
            print "Please try other DSSP binaries included with this Software:"
            print ""
            _search_pattern = os.path.join(glob_fpath_script_dir, 'DSSP', 'dssp_' + glob_operating_system + r'*')
            import glob
            _alternative_dssp_files = glob.glob(_search_pattern)
            _count = 0
            for __file in _alternative_dssp_files:
                _count += 1
                print "%d) \'%s\'" % (_count, os.path.split(__file)[1])
            print ""
            print "You can specify an alternative DSSP filename with an additional argument, for example:"
            print "\'python %s --dssp my_dssp_executable ...\'" % __file__
            print "or \'python %s --dssp /home/user/tools/BetaTurnTool18/my_dssp_executable ...\'" % __file__
            print ""
            print "If none of them are compatible with your operating system,"
            print "you will need to download or compile your own DSSP to make this Software work."
        else:
            print "Cannot locate DSSP, \'%s\'." % glob_fPath_dssp_binary
            print ""
            print "This Software relies on DSSP, a secondary structure assignment tool."
            print "Please make sure its path and filename are correct."
            print ""
            print "You can specify the DSSP filename with an additional argument, for example:"
            print "\'python %s --dssp my_dssp_executable ...\'" % __file__
            print "or \'python %s --dssp /home/user/tools/BetaTurnTool18/my_dssp_executable ...\'" % __file__
        print "********************************************************************"
        print ""
        exit(1)

    return _dssp_class

def ScanInputModelAndAllItsChainsForBetaTurnsAndTheirTypes(_proteinModel, _dssp_class, _outputfile, _fileNameStructure, _how_to_process_3_helix, _args):

    #http://biopython.org/DIST/docs/api/Bio.SeqIO.PdbIO-module.html
    _dict_of_seqres_by_chain = {}
    for record in Bio.SeqIO.parse(_fileNameStructure, "pdb-seqres"):
        _dict_of_seqres_by_chain[record.annotations["chain"]] = record.seq._data

    _torsionNameDualList = [['omega2','medoid_omega2'], ['phi2', 'medoid_phi2'], ['psi2', 'medoid_psi2'], ['omega3', 'medoid_omega3'], ['phi3', 'medoid_phi3'], ['psi3', 'medoid_psi3'], ['omega4','medoid_omega4']]

    _detected_beta_turns_count = 0

    one = None
    two = None
    thr = None
    fou = None

    for _chain in _proteinModel:
        _chain_id = _chain.id

        _PDB4_originalcase = (os.path.splitext(os.path.basename(_fileNameStructure))[0])
        if not _args.quiet and not _args.no_comments:
            print "# "
            print "# Structure_name  = %s" % (_PDB4_originalcase)
            print "# Structure_chain = %s" % (_chain_id)
            print "# "

        PrintColumnNames(_outputfile, _args)

        table_of_bturn_info_strings_as_dict_by_index_of_res1_withcoord = {}
        if _chain_id in _dict_of_seqres_by_chain.keys():
            fullSeqFromPDBSeqResRecord = _dict_of_seqres_by_chain[_chain_id]
        else:
            fullSeqFromPDBSeqResRecord = None
        seqOnMyOwnWCoords = ''
        ssFromDSSPWCoords = ''
        #of residue where exactly it is
        _wcoordindex = -1

        bturns_dict_by_index_of_res1_withcoord = {}
        bturn_is_processed_dict_by_index_of_res1_withcoord = {}

        for _residue in _chain:
            is_standard_20aa = True
            if _residue.resname not in ['ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU', 'GLY', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE', 'PRO', 'SER', 'THR', 'TRP', 'TYR', 'VAL']:
                is_standard_20aa = False

            if is_standard_20aa == False:
                if Bio.PDB.is_aa(_residue) == False:
                    continue
                if len(_residue.resname.strip()) <= 2:
                    continue
                if _residue.id[0] != ' ':
                    if len(_residue.child_list) <= 1:
                        continue
                    if 'N' not in _residue.child_dict.keys() or 'CA' not in _residue.child_dict.keys() or 'C' not in _residue.child_dict.keys():
                        continue

            #to fight HETATM standard aa after TER (another option OXT atom in the terminal residue)
            if is_standard_20aa == True:
                if _residue.id[0] != ' ':
                    continue

            #at the end of execution
            if fullSeqFromPDBSeqResRecord != None and len(seqOnMyOwnWCoords) + 1 > len(fullSeqFromPDBSeqResRecord):
                break

            one = two
            two = thr
            thr = fou
            if is_standard_20aa == True:
                fou = _residue
                seqOnMyOwnWCoords = seqOnMyOwnWCoords + Bio.SeqUtils.IUPACData.protein_letters_3to1[_residue.resname.title()]
                _wcoordindex += 1
            else:
                fou = None
                #more generic definition of a residue (ATOM vs HETATM)
                if Bio.PDB.is_aa(_residue):
                    #sometimes it does not detect GDP with HETAM with is_aa method (not reliable)
                    #08/11/2018 - to process modified residues properly - not to cause shift in SS, we need to continue:
                    #seqOnMyOwnWCoords = seqOnMyOwnWCoords + '?'
                    #no continie (before)
                    seqOnMyOwnWCoords = seqOnMyOwnWCoords + ''
                    continue
                else:
                    raise Exception('Error: impossible because of the condition few lines above')

            if (_chain_id, _residue.id) in _dssp_class:
                ssFromDSSPWCoords = ssFromDSSPWCoords + _dssp_class[(_chain_id, _residue.id)][2].replace('-', 'C')
            else:
                if (_chain_id, (' ', _residue.id[1], ' ')) in _dssp_class:
                    ssFromDSSPWCoords = ssFromDSSPWCoords + _dssp_class[(_chain_id, (' ', _residue.id[1], ' '))][2].replace('-', 'C')
                else:
                    ssFromDSSPWCoords = ssFromDSSPWCoords + '?'
                    continue

            if one != None and two != None and thr != None and fou != None:
                if (_chain_id, one.id) in _dssp_class:
                    SS1 = _dssp_class[(_chain_id, one.id)][2].replace('-', 'C')
                elif (_chain_id, (' ', one.id, ' ')) in _dssp_class:
                    SS1 = _dssp_class[(_chain_id, (' ', one.id, ' '))][2].replace('-', 'C')
                else:
                    continue

                if (_chain_id, two.id) in _dssp_class:
                    SS2 = _dssp_class[(_chain_id, two.id)][2].replace('-', 'C')
                elif (_chain_id, (' ', two.id, ' ')) in _dssp_class:
                    SS2 = _dssp_class[(_chain_id, (' ', two.id, ' '))][2].replace('-', 'C')
                else:
                    continue

                if (_chain_id, thr.id) in _dssp_class:
                    SS3 = _dssp_class[(_chain_id, thr.id)][2].replace('-', 'C')
                elif (_chain_id, (' ', thr.id, ' ')) in _dssp_class:
                    SS3 = _dssp_class[(_chain_id, (' ', thr.id, ' '))][2].replace('-', 'C')
                else:
                    continue

                if (_chain_id, fou.id) in _dssp_class:
                    SS4 = _dssp_class[(_chain_id, fou.id)][2].replace('-', 'C')
                elif (_chain_id, (' ', fou.id, ' ')) in _dssp_class:
                    SS4 = _dssp_class[(_chain_id, (' ', fou.id, ' '))][2].replace('-', 'C')
                else:
                    continue

                #here used to be a condition checking _report_all_residues and SS2/SS3 for E, H, G and I
                if _args.print_any_4_res_segments:
                    pass
                else:
                    #Do not allow E, H or I at SS2 or SS3
                    #Keep processing of G for later
                    if SS2 == 'E' or SS2 == 'H' or SS2 == 'I' or \
                        SS3 == 'E' or SS3 == 'H' or SS3 == 'I':
                            continue

                #checking and defining required atoms
                _allReqsMet = True
                #used later for alternative confirmations
                _1st_atoms_involved = []
                _2nd_atoms_involved = []
                _3rd_atoms_involved = []
                _4th_atoms_involved = []

                #one
                if 'CA' in one.child_dict.keys():
                    CA1 = one['CA']
                    _1st_atoms_involved.append(CA1)
                else:
                    _allReqsMet = False
                    continue

                if 'C' in one.child_dict.keys():
                    C1 = one['C']
                    _1st_atoms_involved.append(C1)
                else:
                    _allReqsMet = False
                    continue


                #two
                if 'N' in two.child_dict.keys():
                    N2 = two['N']
                    _2nd_atoms_involved.append(N2)
                else:
                    _allReqsMet = False
                    continue

                if 'CA' in two.child_dict.keys():
                    CA2 = two['CA']
                    _2nd_atoms_involved.append(CA2)
                else:
                    _allReqsMet = False
                    continue

                if 'C' in two.child_dict.keys():
                    C2 = two['C']
                    _2nd_atoms_involved.append(C2)
                else:
                    _allReqsMet = False
                    continue


                #thr
                if 'N' in thr.child_dict.keys():
                    N3 = thr['N']
                    _3rd_atoms_involved.append(N3)
                else:
                    _allReqsMet = False
                    continue

                if 'CA' in thr.child_dict.keys():
                    CA3 = thr['CA']
                    _3rd_atoms_involved.append(CA3)
                else:
                    _allReqsMet = False
                    continue

                if 'C' in thr.child_dict.keys():
                    C3 = thr['C']
                    _3rd_atoms_involved.append(C3)
                else:
                    _allReqsMet = False
                    continue


                #fou aka four
                if 'N' in fou.child_dict.keys():
                    N4 = fou['N']
                    _4th_atoms_involved.append(N4)
                else:
                    _allReqsMet = False
                    continue

                if 'CA' in fou.child_dict.keys():
                    CA4 = fou['CA']
                    _4th_atoms_involved.append(CA4)
                else:
                    _allReqsMet = False
                    continue


                if _allReqsMet == False:
                    raise Exception('Error: investigate we should have already continued the loop')


                #checking whether to skip quad if one of them is
                #disconnected (not bonded with the previous one)
                CA1CA2 = CA2 - CA1
                CA2CA3 = CA3 - CA2
                CA3CA4 = CA4 - CA3

                if global_SkipProcessingOfAlternativeConformations == True:
                    #we enforce stricter requirements when we process single conformations only
                    if CA1.altloc != C1.altloc:
                        continue

                    if N2.altloc != CA2.altloc or CA2.altloc != C2.altloc:
                        continue

                    #3 is skipped on purpose

                    if N4.altloc != CA4.altloc:
                        continue
                else:
                    #we weaken requirements on alternative conformations when we process them
                    pass

                if CA1CA2 > 4.5:
                    continue
                if CA2CA3 > 4.5:
                    continue
                if CA3CA4 > 4.5:
                    continue

                #figuring out disordered level of thr aka third with regard
                #to one, two and fou
                one_residue_is_disordered = bool(one.disordered)
                two_residue_is_disordered = bool(two.disordered)
                thr_residue_is_disordered = bool(thr.disordered)
                fou_residue_is_disordered = bool(fou.disordered)

                parent_quad_disorder_class = -1
                #pay attention it relates to the atoms involved only
                #for one, two and fou. They are N and CA and C right now!
                if thr_residue_is_disordered == False and (one_residue_is_disordered == False and two_residue_is_disordered == False and fou_residue_is_disordered == False):
                    parent_quad_disorder_class = 10000
                    for atom in (_1st_atoms_involved + _2nd_atoms_involved + _4th_atoms_involved):
                        if atom.occupancy < 1:
                            parent_quad_disorder_class = 11000
                            break
                    for atom in _3rd_atoms_involved:
                        if atom.occupancy < 1:
                            parent_quad_disorder_class = 12000
                            break
                elif thr_residue_is_disordered == False and (one_residue_is_disordered == True or two_residue_is_disordered == True or fou_residue_is_disordered == True):
                    parent_quad_disorder_class = 13000
                    for atom in _3rd_atoms_involved:
                        if atom.occupancy < 1:
                            parent_quad_disorder_class = 13100
                            break
                    for atom in (_1st_atoms_involved + _2nd_atoms_involved + _4th_atoms_involved):
                        if hasattr(atom, 'child_dict'):
                            if (parent_quad_disorder_class == 13000 or parent_quad_disorder_class == 13100) and (atom.id == 'N' or atom.id == 'CA' or atom.id == 'C' or atom.id == 'O'):
                                parent_quad_disorder_class += 10
                                break
                elif thr_residue_is_disordered == True and (one_residue_is_disordered == False and two_residue_is_disordered == False and fou_residue_is_disordered == False):
                    parent_quad_disorder_class = 20000
                    for atom in (_1st_atoms_involved + _2nd_atoms_involved + _4th_atoms_involved):
                        if atom.occupancy < 1:
                            parent_quad_disorder_class = 21000
                            break
                elif thr_residue_is_disordered == True and (one_residue_is_disordered == True or two_residue_is_disordered == True or fou_residue_is_disordered == True):
                    parent_quad_disorder_class = 30000
                else:
                    raise Exception('Error: it must not happen -- please investigate')

                _altLoop_3rd = []
                if parent_quad_disorder_class >= 10000 and parent_quad_disorder_class < 20000:
                    #even when there are alternative confirmation -- still
                    #take the main one (1.3 or 1.31) for neighbors
                    _altLoop_3rd = [' ']
                elif parent_quad_disorder_class >= 20000 and parent_quad_disorder_class < 30000:
                    #there are no disordered confirmations for neigbors at
                    #all -- clean
                    _altLoop_3rd = []
                    for atom in _3rd_atoms_involved:
                        if hasattr(atom, 'child_dict'):
                            if (parent_quad_disorder_class == 20000 or parent_quad_disorder_class == 21000) and (atom.id == 'N' or atom.id == 'CA' or atom.id == 'C' or atom.id == 'O'):
                                parent_quad_disorder_class += 100
                            _altLoop_3rd = _altLoop_3rd + atom.child_dict.keys()
                    _altLoop_3rd = list(set(_altLoop_3rd))
                elif parent_quad_disorder_class >= 30000 and parent_quad_disorder_class < 40000:
                    #we demand main confirmation on neighbors -- do no try
                    #other combinations
                    _altLoop_3rd = []
                    for atom in _3rd_atoms_involved:
                        if hasattr(atom, 'child_dict'):
                            if parent_quad_disorder_class == 30000 and (atom.id == 'N' or atom.id == 'CA' or atom.id == 'C' or atom.id == 'O'):
                                parent_quad_disorder_class += 100
                            _altLoop_3rd = _altLoop_3rd + atom.child_dict.keys()
                    _altLoop_3rd = list(set(_altLoop_3rd))
                    for atom in (_1st_atoms_involved + _2nd_atoms_involved + _4th_atoms_involved):
                        if hasattr(atom, 'child_dict'):
                            if (parent_quad_disorder_class == 30000 or parent_quad_disorder_class == 30100) and (atom.id == 'N' or atom.id == 'CA' or atom.id == 'C' or atom.id == 'O'):
                                parent_quad_disorder_class += 10
                                break


                if parent_quad_disorder_class < 0:
                    raise Exception('Error: parent_quad_disorder_class had to be defined already')

                if global_SkipProcessingOfAlternativeConformations == False:
                    #to enforce only the main conformation for third residue and main conformations for first, second and forth (no matter single-conformational or multiple-conformational)
                    _altLoop_3rd = [' ']

                #atoms for neighbors stay the same -- we already pulled
                #the main ones
                for _alt_3rd in _altLoop_3rd:
                    quad_disorder_class = parent_quad_disorder_class
                    if _alt_3rd != ' ':
                        _altConfForAll3rdAtomsFound = True

                        if thr['N'].disordered_flag == 1:
                            if _alt_3rd in thr['N'].child_dict.keys():
                                N3 = thr['N'].child_dict[_alt_3rd]
                            else:
                                N3 = thr['N']
                                _altConfForAll3rdAtomsFound = False
                        else:
                            N3 = thr['N']
                            _altConfForAll3rdAtomsFound = False

                        if thr['CA'].disordered_flag == 1:
                            if _alt_3rd in thr['CA'].child_dict.keys():
                                CA3 = thr['CA'].child_dict[_alt_3rd]
                            else:
                                CA3 = thr['CA']
                                _altConfForAll3rdAtomsFound = False
                        else:
                            CA3 = thr['CA']
                            _altConfForAll3rdAtomsFound = False

                        if thr['C'].disordered_flag == 1:
                            if _alt_3rd in thr['C'].child_dict.keys():
                                C3 = thr['C'].child_dict[_alt_3rd]
                            else:
                                C3 = thr['C']
                                _altConfForAll3rdAtomsFound = False
                        else:
                            C3 = thr['C']
                            _altConfForAll3rdAtomsFound = False

                        if _altConfForAll3rdAtomsFound == False:
                            quad_disorder_class += 1

                        #need to recalculate
                        CA1CA2 = CA2 - CA1
                        CA2CA3 = CA3 - CA2
                        CA3CA4 = CA4 - CA3

                        if CA1CA2 > 4.5:
                            continue
                        if CA2CA3 > 4.5:
                            continue
                        if CA3CA4 > 4.5:
                            continue

                    #end of if _alt_3rd != ' ':

                    #distance
                    CA1CA4 = CA4 - CA1

                    #_wcoordindex - 3 corresponds to the first residue of a beta turn
                    bturn_is_processed_dict_by_index_of_res1_withcoord[_wcoordindex - 3] = True
                    if _args.print_any_4_res_segments:
                        pass
                    else:
                        if CA1CA4 > CA1CA4_beta_turn_distance_cutoff:
                            continue

                        if global_SkipProcessingOfAlternativeConformations == True:
                            if quad_disorder_class != 10000:
                                continue
                        else:
                            #do not demand single-conformational and 1.0 at 1st, 2nd, 3rd and 4th residues any longer (03/23/2018)
                            pass

                    #defining required atom vectors
                    #one aka 1
                    CA1vec = CA1.get_vector()
                    C1vec = C1.get_vector()
                    #two aka 2
                    N2vec = N2.get_vector()
                    CA2vec = CA2.get_vector()
                    C2vec = C2.get_vector()
                    #three aka 3
                    N3vec = N3.get_vector()
                    CA3vec = CA3.get_vector()
                    C3vec = C3.get_vector()
                    #fou aka 4
                    N4vec = N4.get_vector()
                    CA4vec = CA4.get_vector()


                    #backbone torsion angles for 1 thru 4:
                    #one
                    #psi1 = Bio.PDB.calc_dihedral(N1vec, CA1vec, C1vec, N2vec)
                    #two
                    omega2 = Bio.PDB.calc_dihedral(CA1vec, C1vec, N2vec, CA2vec)
                    phi2 = Bio.PDB.calc_dihedral(C1vec, N2vec, CA2vec, C2vec)
                    psi2 = Bio.PDB.calc_dihedral(N2vec, CA2vec, C2vec, N3vec)
                    #thr aka 3
                    omega3 = Bio.PDB.calc_dihedral(CA2vec, C2vec, N3vec, CA3vec)
                    phi3 = Bio.PDB.calc_dihedral(C2vec, N3vec, CA3vec, C3vec)
                    psi3 = Bio.PDB.calc_dihedral(N3vec, CA3vec, C3vec, N4vec)
                    #fou aka 4
                    omega4 = Bio.PDB.calc_dihedral(CA3vec, C3vec, N4vec, CA4vec)
                    #phi4 = Bio.PDB.calc_dihedral(C3vec, N4vec, CA4vec, C4vec)


                    aa1 = Bio.SeqUtils.IUPACData.protein_letters_3to1[one.resname.title()]
                    aa2 = Bio.SeqUtils.IUPACData.protein_letters_3to1[two.resname.title()]
                    aa3 = Bio.SeqUtils.IUPACData.protein_letters_3to1[thr.resname.title()]
                    aa4 = Bio.SeqUtils.IUPACData.protein_letters_3to1[fou.resname.title()]

                    #find closest beta-turn cluster and report all information for the current beta turn
                    _L1_2Cos_Aver_array = numpy.zeros(len(glob_bTurnLibListOfDict)-1)
                    for j in range(len(glob_bTurnLibListOfDict)-1):
                        for _torsionNamePair in _torsionNameDualList:
                            _L1_2Cos_Aver_array[j] += 2 * (1 - numpy.cos(locals()[_torsionNamePair[0]] - numpy.radians(float(glob_bTurnLibListOfDict[j][_torsionNamePair[1]]))))
                        _L1_2Cos_Aver_array[j] /= len(_torsionNameDualList)

                    _closest_cluster_index = numpy.argmin(_L1_2Cos_Aver_array)
                    _distance_to_closest_cluster_native = _L1_2Cos_Aver_array[_closest_cluster_index]
                    #d2 = 2 * (1 - numpy.cos(numpy.radians(realDeg)))
                    #realDeg = numpy.degrees(numpy.arccos(1 - d2 / 2.))
                    _distance_to_closest_cluster_degree = numpy.degrees(numpy.arccos(1 - _distance_to_closest_cluster_native / 2.))
                    
                    _L1_2Cos_Aver_array[_closest_cluster_index] = 999999.
                    _2nd_closest_cluster_index = numpy.argmin(_L1_2Cos_Aver_array)
                    _distance_to_2nd_closest_cluster_native = _L1_2Cos_Aver_array[_2nd_closest_cluster_index]
                    _distance_to_2nd_closest_cluster_degree = numpy.degrees(numpy.arccos(1 - _distance_to_2nd_closest_cluster_native / 2.))
                    del _L1_2Cos_Aver_array

                    #case (1)
                    _confidence_in_closest_type = (1 - _distance_to_closest_cluster_degree / (_distance_to_closest_cluster_degree + _distance_to_2nd_closest_cluster_degree))
                    _confidence_in_2nd_closest_type = (1 - _distance_to_2nd_closest_cluster_degree / (_distance_to_closest_cluster_degree + _distance_to_2nd_closest_cluster_degree))

                    if not _args.exclude_other_group_from_turn_assignment:
                        if not _args.yes_2nd_turn_alternative_for_other_group:
                            if _distance_to_closest_cluster_native > glob_max_L1Distance_betw_closestMedoid_sample_otherwise_Other:
                                #case (3)
                                #When 1st_closest is above the threshold, both 1st and 2nd closest must be above the thresold
                                if _distance_to_2nd_closest_cluster_native <= glob_max_L1Distance_betw_closestMedoid_sample_otherwise_Other:
                                    raise('Error: impossible that the 2nd closest is not above threshold while the 1st one is above');
                                #we assign the 1st closest type to Other
                                _closest_cluster_index = len(glob_bTurnLibListOfDict)-1
                                #the distance to Other (1st) does not have a defintion, so 999 with positive value, to make it large
                                _distance_to_closest_cluster_native = 999
                                _distance_to_closest_cluster_degree = 999
                                _confidence_in_closest_type = 1.0
                                #we assign the 2nd closest type to Other as well
                                _2nd_closest_cluster_index = len(glob_bTurnLibListOfDict)-1
                                #the distance to Other (1st) does not have a defintion, so 999 with positive value, to make it large
                                _distance_to_2nd_closest_cluster_native = 999
                                _distance_to_2nd_closest_cluster_degree = 999
                                _confidence_in_2nd_closest_type = 0.0
                            elif _distance_to_2nd_closest_cluster_native > glob_max_L1Distance_betw_closestMedoid_sample_otherwise_Other:
                                #case (2)
                                #When the 1st stays with one of 18 types and does NOT become Other,
                                #however the 2nd above the threshold and becomes Other
                                #This is because being close enough to one turn and not remotely close to another turn, means our confidence in C1 should be 1.0
                                _confidence_in_closest_type = 1.0
                                _2nd_closest_cluster_index = len(glob_bTurnLibListOfDict)-1
                                #the distance to Other (2nd) does not have a defintion, so 999 with positive value, to make it large
                                _distance_to_2nd_closest_cluster_native = 999
                                _distance_to_2nd_closest_cluster_degree = 999
                                _confidence_in_2nd_closest_type = 0.0
                        else:
                            if _distance_to_closest_cluster_native > glob_max_L1Distance_betw_closestMedoid_sample_otherwise_Other:
                                #case (3)
                                #When 1st_closest is above the threshold, both 1st and 2nd closest must be above the thresold
                                if _distance_to_2nd_closest_cluster_native <= glob_max_L1Distance_betw_closestMedoid_sample_otherwise_Other:
                                    raise('Error: impossible that the 2nd closest is not above threshold while the 1st one is above');

                                #we turn the 1st closest type into the 2nd one
                                _2nd_closest_cluster_index = _closest_cluster_index
                                _distance_to_2nd_closest_cluster_native = _distance_to_closest_cluster_native
                                _distance_to_2nd_closest_cluster_degree = _distance_to_closest_cluster_degree
                                #we assign the 1st closest type to Other
                                _closest_cluster_index = len(glob_bTurnLibListOfDict)-1
                                #the distance to Other (1st) does not have a defintion, so 999 with positive value, to make it large
                                _distance_to_closest_cluster_native = 999
                                _distance_to_closest_cluster_degree = 999
                                #We set Other (1st) with confidence of 0.5 at the border and the rest goes to the original 1st (now 2nd)
                                #Pay attention that _distance_to_2nd_closest_cluster_native now holds the original 1st closest _distance_to_closest_cluster_native
                                #after reassignment
                                _confidence_in_2nd_closest_type = 1 - 0.5 * _distance_to_2nd_closest_cluster_native/glob_max_L1Distance_betw_closestMedoid_sample_otherwise_Other
                                #It is possible that the original closest cluster (now 2nd choice) is too far away from the border.
                                #More exactly twice the distance threshold. We cannot allow negative confidence or probability,
                                #so we set it to 0.0
                                if _confidence_in_2nd_closest_type < 0:
                                    _confidence_in_2nd_closest_type = 0.0
                                _confidence_in_closest_type = 1 - _confidence_in_2nd_closest_type

                            elif _distance_to_2nd_closest_cluster_native > glob_max_L1Distance_betw_closestMedoid_sample_otherwise_Other:
                                #case (2)
                                #When the 1st stays with one of 18 types and does NOT become Other,
                                #however the 2nd above the threshold and becomes Other
                                _2nd_closest_cluster_index = len(glob_bTurnLibListOfDict)-1
                                #the distance to Other (2nd) does not have a defintion, so 999 with positive value, to make it large
                                _distance_to_2nd_closest_cluster_native = 999
                                _distance_to_2nd_closest_cluster_degree = 999
                                #_confidence_in_closest_type cannot become negative because with this 2nd condition,
                                #_distance_to_closest_cluster_native is already satisfied to be below the threshold
                                _confidence_in_closest_type = 1 - 0.5 * _distance_to_closest_cluster_native/glob_max_L1Distance_betw_closestMedoid_sample_otherwise_Other
                                _confidence_in_2nd_closest_type = 1 - _confidence_in_closest_type

                    #to make sure confidence_letter's are in [0, 9] range (with a single digit) and not [0, 10]
                    if _confidence_in_closest_type >= 1.0:
                        _confidence_in_closest_type = 1.0 - 1e-9
                    if _confidence_in_2nd_closest_type >= 1.0:
                        _confidence_in_2nd_closest_type = 1.0 - 1e-9

                    border_case = '.'
                    if _confidence_in_closest_type < glob_border_confidence_value:
                        border_case = '+'

                    #_wcoordindex - 3 corresponds to the first residue of a beta turn
                    bturns_dict_by_index_of_res1_withcoord[_wcoordindex - 3] = {}
                    bturns_dict_by_index_of_res1_withcoord[_wcoordindex - 3]['primary_one_letter'] = glob_bTurnLibListOfDict[_closest_cluster_index]['one_letter']
                    bturns_dict_by_index_of_res1_withcoord[_wcoordindex - 3]['primary_confidence_letter'] = str(int(math.floor(_confidence_in_closest_type * 100. / 10.)))
                    bturns_dict_by_index_of_res1_withcoord[_wcoordindex - 3]['border_case'] = border_case
                    bturns_dict_by_index_of_res1_withcoord[_wcoordindex - 3]['secondary_one_letter'] = glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['one_letter']
                    bturns_dict_by_index_of_res1_withcoord[_wcoordindex - 3]['secondary_confidence_letter'] = str(int(math.floor(_confidence_in_2nd_closest_type * 100. / 10.)))
                    bturns_dict_by_index_of_res1_withcoord[_wcoordindex - 3]['primary_distanceDeg'] = _distance_to_closest_cluster_degree
                    bturns_dict_by_index_of_res1_withcoord[_wcoordindex - 3]['primary_distanceL1'] = _distance_to_closest_cluster_native
                    bturns_dict_by_index_of_res1_withcoord[_wcoordindex - 3]['secondary_distanceDeg'] = _distance_to_2nd_closest_cluster_degree
                    bturns_dict_by_index_of_res1_withcoord[_wcoordindex - 3]['secondary_distanceL1'] = _distance_to_2nd_closest_cluster_native

                    string_1st_closest_with_optional_mode_and_or_medoid_torsions = ''
                    if _args.report_closest_mode_torsions:
                        string_1st_closest_with_optional_mode_and_or_medoid_torsions += ' %-10s %-10s %-10s %-10s %-10s %-10s %-10s' % (
                            glob_bTurnLibListOfDict[_closest_cluster_index]['mode_omega2'],
                            glob_bTurnLibListOfDict[_closest_cluster_index]['mode_phi2'],
                            glob_bTurnLibListOfDict[_closest_cluster_index]['mode_psi2'],
                            glob_bTurnLibListOfDict[_closest_cluster_index]['mode_omega3'],
                            glob_bTurnLibListOfDict[_closest_cluster_index]['mode_phi3'],
                            glob_bTurnLibListOfDict[_closest_cluster_index]['mode_psi3'],
                            glob_bTurnLibListOfDict[_closest_cluster_index]['mode_omega4']
                            )

                    if _args.report_closest_medoid_torsions:
                        string_1st_closest_with_optional_mode_and_or_medoid_torsions += ' %-10s %-10s %-10s %-10s %-10s %-10s %-10s' % (
                            glob_bTurnLibListOfDict[_closest_cluster_index]['medoid_omega2'],
                            glob_bTurnLibListOfDict[_closest_cluster_index]['medoid_phi2'],
                            glob_bTurnLibListOfDict[_closest_cluster_index]['medoid_psi2'],
                            glob_bTurnLibListOfDict[_closest_cluster_index]['medoid_omega3'],
                            glob_bTurnLibListOfDict[_closest_cluster_index]['medoid_phi3'],
                            glob_bTurnLibListOfDict[_closest_cluster_index]['medoid_psi3'],
                            glob_bTurnLibListOfDict[_closest_cluster_index]['medoid_omega4']
                            )

                    string_2nd_closest_with_optional_mode_and_or_medoid_torsions = ''
                    if _args.report_closest_mode_torsions:
                        string_2nd_closest_with_optional_mode_and_or_medoid_torsions += ' %-10s %-10s %-10s %-10s %-10s %-10s %-10s' % (
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['mode_omega2'],
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['mode_phi2'],
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['mode_psi2'],
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['mode_omega3'],
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['mode_phi3'],
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['mode_psi3'],
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['mode_omega4']
                            )

                    if _args.report_closest_medoid_torsions:
                        string_2nd_closest_with_optional_mode_and_or_medoid_torsions += ' %-10s %-10s %-10s %-10s %-10s %-10s %-10s' % (
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['medoid_omega2'],
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['medoid_phi2'],
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['medoid_psi2'],
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['medoid_omega3'],
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['medoid_phi3'],
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['medoid_psi3'],
                            glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['medoid_omega4']
                            )

                    #_fileNameStructure
                    _lineToPrint = '%-7s %s %-10s %-5s %-6s %-3s %-6s %-3s %-6s %-6s %-6.3f %-7.2f %-7.2f %-7.2f %-7.2f %-7.2f %-7.2f %-7.2f %-6s %-5.3f %-4s %-5s %-13s %-7s %-6.2f%s %-5.3f %-4s %-5s %-13s %-7s %-6.2f%s' % ('table',
                                                'DETECTED_BTURN_NU',
                                                _PDB4_originalcase,
                                                _chain_id,
                                                (str(one.id[1]) + one.id[2]).strip(),
                                                one.resname,
                                                (str(fou.id[1]) + fou.id[2]).strip(),
                                                fou.resname,
                                                aa1 + aa2 + aa3 + aa4,
                                                SS1 + SS2 + SS3 + SS4,
                                                CA1CA4,
                                                numpy.degrees(omega2 % (2 * numpy.math.pi)),
                                                numpy.degrees(phi2),
                                                numpy.degrees(psi2),
                                                numpy.degrees(omega3 % (2 * numpy.math.pi)),
                                                numpy.degrees(phi3),
                                                numpy.degrees(psi3),
                                                numpy.degrees(omega4 % (2 * numpy.math.pi)),
                                                border_case,
                                                _confidence_in_closest_type,
                                                glob_bTurnLibListOfDict[_closest_cluster_index]['no_by_size'],
                                                glob_bTurnLibListOfDict[_closest_cluster_index]['bturn_name'],
                                                glob_bTurnLibListOfDict[_closest_cluster_index]['prev_name'],
                                                glob_bTurnLibListOfDict[_closest_cluster_index]['one_letter'],
                                                _distance_to_closest_cluster_degree,
                                                string_1st_closest_with_optional_mode_and_or_medoid_torsions,
                                                _confidence_in_2nd_closest_type,
                                                glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['no_by_size'],
                                                glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['bturn_name'],
                                                glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['prev_name'],
                                                glob_bTurnLibListOfDict[_2nd_closest_cluster_index]['one_letter'],
                                                _distance_to_2nd_closest_cluster_degree,
                                                string_2nd_closest_with_optional_mode_and_or_medoid_torsions)

                    #_wcoordindex - 3 corresponds to the first residue of a beta turn
                    table_of_bturn_info_strings_as_dict_by_index_of_res1_withcoord[_wcoordindex - 3] = _lineToPrint

                #end of for _alt_3rd in _altLoop_3rd:
            #end of if one != None and two != None and thr != None and fou != None:

            #additional fix
            if 'OXT' in _residue.child_dict.keys():
                break
        #end of for _residue in _chain:

        if fullSeqFromPDBSeqResRecord == None:
            fullSeqFromPDBSeqResRecord = seqOnMyOwnWCoords
        if len(fullSeqFromPDBSeqResRecord) > 0 and len(seqOnMyOwnWCoords) > 0:
            alignment = Bio.pairwise2.align.globalxx(fullSeqFromPDBSeqResRecord, seqOnMyOwnWCoords, one_alignment_only=True)

            if len(alignment[0][0]) != len(fullSeqFromPDBSeqResRecord):
                print 'DEBUG' + '\t' + _PDB4_originalcase + '\t' + _chain_id + '\t' + fullSeqFromPDBSeqResRecord
                print 'DEBUG' + '\t' + _PDB4_originalcase + '\t' + _chain_id + '\t' + seqOnMyOwnWCoords
                print 'DEBUG' + '\t' + _PDB4_originalcase + '\t' + _chain_id + '\t' + alignment[0][0]
                print 'DEBUG' + '\t' + _PDB4_originalcase + '\t' + _chain_id + '\t' + alignment[0][1]
                raise Exception('Error: investigate #1, len(alignment[0][0]) != len(fullSeqFromPDBSeqResRecord)')

            if alignment[0][0] != fullSeqFromPDBSeqResRecord:
                raise Exception('Error: investigate #2, alignment[0][0] != fullSeqFromPDBSeqResRecord')
        else:
            continue

        if len(seqOnMyOwnWCoords) != len(ssFromDSSPWCoords):
            raise Exception('Error: investigate #3, for some reason a length of a aa sequence with coordinates and a sequence of DSSP are not equal')

        #printing table after a chain is processed
        if not _args.quiet or _outputfile != None:
            if _how_to_process_3_helix == 'default_allow_isolated_GGG':
                _pattern = re.compile('(?<!H|G)G{3,3}(?!H|G)')
                modifableDSSPTemporary = _pattern.sub('ggg', ssFromDSSPWCoords)
            else:
                modifableDSSPTemporary = ssFromDSSPWCoords

            j = -1
            for i in range(len(fullSeqFromPDBSeqResRecord)):
                #fullSeqFromPDBSeqResRecord[i]
                if alignment[0][1][i] == '-':
                    continue
                else:
                    j += 1
                    if j in bturn_is_processed_dict_by_index_of_res1_withcoord:
                        if _args.print_any_4_res_segments:
                            pass
                        else:
                            if _how_to_process_3_helix == 'default_allow_isolated_GGG' or _how_to_process_3_helix == 'exclude_all_G':
                                if modifableDSSPTemporary[j-1] == 'G' or modifableDSSPTemporary[j] == 'G':
                                    del bturn_is_processed_dict_by_index_of_res1_withcoord[j]
                                    table_of_bturn_info_strings_as_dict_by_index_of_res1_withcoord.pop(j, None)
                                    bturns_dict_by_index_of_res1_withcoord.pop(j, None)

                            elif _how_to_process_3_helix == 'include_all_G':
                                pass

                    if j in table_of_bturn_info_strings_as_dict_by_index_of_res1_withcoord:
                        _detected_beta_turns_count += 1

                        table_of_bturn_info_strings_as_dict_by_index_of_res1_withcoord[j] = table_of_bturn_info_strings_as_dict_by_index_of_res1_withcoord[j].replace('DETECTED_BTURN_NU', '%-6d' % _detected_beta_turns_count)
                        if not _args.quiet and not _args.no_table_format:
                            print table_of_bturn_info_strings_as_dict_by_index_of_res1_withcoord[j]

                        if _outputfile != None and not _args.no_table_format:
                            _outputfile.write("%s\n" % (table_of_bturn_info_strings_as_dict_by_index_of_res1_withcoord[j]))

            #print beta-turn info in the sequence format
            if not _args.no_seq_format or _args.yes_singleline_format:
                _title_line1 = 'sequence\t%s\t%s\tFull__aa__sequence\t' % (_PDB4_originalcase, _chain_id)
                _title_line2 = 'sequence\t%s\t%s\tSeq___with___coord\t' % (_PDB4_originalcase, _chain_id)
                _title_line3 = 'sequence\t%s\t%s\tDSSP___sec__struct\t' % (_PDB4_originalcase, _chain_id)
                _title_line4 = 'sequence\t%s\t%s\tPrimary_bturn___18\t' % (_PDB4_originalcase, _chain_id)
                _title_line5 = 'sequence\t%s\t%s\tPrimary_confi___18\t' % (_PDB4_originalcase, _chain_id)
                _title_line6 = 'sequence\t%s\t%s\tBorder__case____18\t' % (_PDB4_originalcase, _chain_id)
                _title_line7 = 'sequence\t%s\t%s\tSeconda_bturn___18\t' % (_PDB4_originalcase, _chain_id)
                _title_line8 = 'sequence\t%s\t%s\tSeconda_confi___18\t' % (_PDB4_originalcase, _chain_id)
                _title_line9 = 'sequence\t%s\t%s\tIs_processed____18\t' % (_PDB4_originalcase, _chain_id)
                _title_lin9b = 'sequence\t%s\t%s\tPrimary_distDeg_18\t' % (_PDB4_originalcase, _chain_id)
                _title_lin9c = 'sequence\t%s\t%s\tPrimary_distL___18\t' % (_PDB4_originalcase, _chain_id)
                _title_lin9d = 'sequence\t%s\t%s\tSeconda_distDeg_18\t' % (_PDB4_originalcase, _chain_id)
                _title_lin9e = 'sequence\t%s\t%s\tSeconda_distL___18\t' % (_PDB4_originalcase, _chain_id)
                _content1 = ''
                _content2 = ''
                _content3 = ''
                _content4 = ''
                _content5 = ''
                _content6 = ''
                _content7 = ''
                _content8 = ''
                _content9 = ''
                _conten9b = ''
                _conten9c= ''
                _conten9d = ''
                _conten9e = ''
                j = -1
                for i in range(len(fullSeqFromPDBSeqResRecord)):
                    _content1 += fullSeqFromPDBSeqResRecord[i]
                    if alignment[0][1][i] == '-':
                        _content2 += '-'
                        _content3 += 'X'
                        _content4 += 'X'
                        _content5 += 'X'
                        _content6 += 'X'
                        _content7 += 'X'
                        _content8 += 'X'
                        _content9 += 'X'
                        _conten9b += '-9;'
                        _conten9c += '-9;'
                        _conten9d += '-9;'
                        _conten9e += '-9;'
                    else:
                        j += 1
                        _content2 += seqOnMyOwnWCoords[j]
                        _content3 += ssFromDSSPWCoords[j]

                        if j in bturns_dict_by_index_of_res1_withcoord:
                            _content4 += bturns_dict_by_index_of_res1_withcoord[j]['primary_one_letter']
                            _content5 += bturns_dict_by_index_of_res1_withcoord[j]['primary_confidence_letter']
                            _content6 += bturns_dict_by_index_of_res1_withcoord[j]['border_case']
                            _content7 += bturns_dict_by_index_of_res1_withcoord[j]['secondary_one_letter']
                            _content8 += bturns_dict_by_index_of_res1_withcoord[j]['secondary_confidence_letter']
                            _conten9b += '%.2f;' % bturns_dict_by_index_of_res1_withcoord[j]['primary_distanceDeg']
                            _conten9c += '%.4f;' % bturns_dict_by_index_of_res1_withcoord[j]['primary_distanceL1']
                            _conten9d += '%.2f;' % bturns_dict_by_index_of_res1_withcoord[j]['secondary_distanceDeg']
                            _conten9e += '%.4f;' % bturns_dict_by_index_of_res1_withcoord[j]['secondary_distanceL1']
                        else:
                            _content4 += ' '
                            _content5 += ' '
                            _content6 += ' '
                            _content7 += ' '
                            _content8 += ' '
                            _conten9b += '-1;'
                            _conten9c += '-1;'
                            _conten9d += '-1;'
                            _conten9e += '-1;'

                        if j in bturn_is_processed_dict_by_index_of_res1_withcoord and bturn_is_processed_dict_by_index_of_res1_withcoord[j] == True:
                            _content9 += '+'
                        else:
                            _content9 += '-'

                if _conten9b[-1] == ';':
                    _conten9b = _conten9b[:-1]
                if _conten9c[-1] == ';':
                    _conten9c = _conten9c[:-1]
                if _conten9d[-1] == ';':
                    _conten9d = _conten9d[:-1]
                if _conten9e[-1] == ';':
                    _conten9e = _conten9e[:-1]

                if not _args.quiet and not _args.no_comments and not _args.no_seq_format:
                    print "# "
                    print "# Detected beta turns in a sequence format:"
                    print "# -----------------------------------------"
                    print "# "
                if not _args.quiet and not _args.no_seq_format:
                    print _title_line1 + _content1
                    print _title_line2 + _content2
                    print _title_line3 + _content3
                    print _title_line4 + _content4
                    print _title_line5 + _content5
                    print _title_line6 + _content6
                    print _title_line7 + _content7
                    print _title_line8 + _content8
                    print _title_line9 + _content9
                    print _title_lin9b + _conten9b
                    print _title_lin9c + _conten9c
                    print _title_lin9d + _conten9d
                    print _title_lin9e + _conten9e
                if _outputfile != None and not _args.no_seq_format:
                    _outputfile.write("%s\n" % (_title_line1 + _content1))
                    _outputfile.write("%s\n" % (_title_line2 + _content2))
                    _outputfile.write("%s\n" % (_title_line3 + _content3))
                    _outputfile.write("%s\n" % (_title_line4 + _content4))
                    _outputfile.write("%s\n" % (_title_line5 + _content5))
                    _outputfile.write("%s\n" % (_title_line6 + _content6))
                    _outputfile.write("%s\n" % (_title_line7 + _content7))
                    _outputfile.write("%s\n" % (_title_line8 + _content8))
                    _outputfile.write("%s\n" % (_title_line9 + _content9))
                    _outputfile.write("%s\n" % (_title_lin9b + _conten9b))
                    _outputfile.write("%s\n" % (_title_lin9c + _conten9c))
                    _outputfile.write("%s\n" % (_title_lin9d + _conten9d))
                    _outputfile.write("%s\n" % (_title_lin9e + _conten9e))
                if not _args.quiet and not _args.no_comments and _args.yes_singleline_format:
                    print "# "
                    print "# Detected beta turns in a single-line format:"
                    print "# --------------------------------------------"
                    print "# "
                if not _args.quiet and _args.yes_singleline_format:
                    print 'singleline' + '\t' + _PDB4_originalcase + '\t' + _chain_id + '\t' + _content1 + '\t' + _content2 + '\t' + _content3 + '\t' + _content4 + '\t' + _content5 + '\t' + _content6 + '\t' + _content7 + '\t' + _content8 + '\t' + _content9 + '\t' + _conten9b + '\t' + _conten9c + '\t' + _conten9d + '\t' + _conten9e
                if _outputfile != None and _args.yes_singleline_format:
                    _outputfile.write("%s\n" % ('singleline' + '\t' + _PDB4_originalcase + '\t' + _chain_id + '\t' + _content1 + '\t' + _content2 + '\t' + _content3 + '\t' + _content4 + '\t' + _content5 + '\t' + _content6 + '\t' + _content7 + '\t' + _content8 + '\t' + _content9 + '\t' + _conten9b + '\t' + _conten9c + '\t' + _conten9d + '\t' + _conten9e))
    #end of for _chain in _proteinModel:

def PrintColumnNames(_outputfile, _args):
    string_1st_closest_with_optional_mode_and_or_medoid_torsions = ''
    if _args.report_closest_mode_torsions:
        string_1st_closest_with_optional_mode_and_or_medoid_torsions += ' %-10s %-10s %-10s %-10s %-10s %-10s %-10s' % (
            'mode1_omg2',
            'mode1_phi2',
            'mode1_psi2',
            'mode1_omg3',
            'mode1_phi3',
            'mode1_psi3',
            'mode1_omg4'
            )

    if _args.report_closest_medoid_torsions:
        string_1st_closest_with_optional_mode_and_or_medoid_torsions += ' %-10s %-10s %-10s %-10s %-10s %-10s %-10s' % (
            'med1_omg2',
            'med1_phi2',
            'med1_psi2',
            'med1_omg3',
            'med1_phi3',
            'med1_psi3',
            'med1_omg4'
            )

    string_2nd_closest_with_optional_mode_and_or_medoid_torsions = ''
    if _args.report_closest_mode_torsions:
        string_2nd_closest_with_optional_mode_and_or_medoid_torsions += ' %-10s %-10s %-10s %-10s %-10s %-10s %-10s' % (
            'mode2_omg2',
            'mode2_phi2',
            'mode2_psi2',
            'mode2_omg3',
            'mode2_phi3',
            'mode2_psi3',
            'mode2_omg4'
            )

    if _args.report_closest_medoid_torsions:
        string_2nd_closest_with_optional_mode_and_or_medoid_torsions += ' %-10s %-10s %-10s %-10s %-10s %-10s %-10s' % (
            'med2_omg2',
            'med2_phi2',
            'med2_psi2',
            'med2_omg3',
            'med2_phi3',
            'med2_psi3',
            'med2_omg4'
            )

    _string_to_print = '%-7s %-6s %-10s %-5s %-6s %-3s %-6s %-3s %-6s %-6s %-6s %-7s %-7s %-7s %-7s %-7s %-7s %-7s %-6s %-5s %-4s %-5s %-13s %-7s %-6s%s %-5s %-4s %-5s %-13s %-7s %-6s%s' % ('rectype',
                                                                                'count',
                                                                                'pdb',
                                                                                'chain',
                                                                                'res1',
                                                                                'aa1',
                                                                                'res4',
                                                                                'aa4',
                                                                                'aa1234',
                                                                                'ss1234',
                                                                                'Ca1Ca4',
                                                                                'omega2',
                                                                                'phi2',
                                                                                'psi2',
                                                                                'omega3',
                                                                                'phi3',
                                                                                'psi3',
                                                                                'omega4',
                                                                                'border',
                                                                                'conf1',
                                                                                'int1',
                                                                                'type1',
                                                                                'prev_name1',
                                                                                'letter1',
                                                                                'd_deg1',
                                                                                string_1st_closest_with_optional_mode_and_or_medoid_torsions,
                                                                                'conf2',
                                                                                'int2',
                                                                                'type2',
                                                                                'prev_name2',
                                                                                'letter2',
                                                                                'd_deg2',
                                                                                string_2nd_closest_with_optional_mode_and_or_medoid_torsions)

    if not _args.quiet and not _args.no_table_format:
        print _string_to_print

    if _outputfile != None:
        if not _args.no_table_format:
            _outputfile.write("%s\n" % (_string_to_print))

def PrintProgramInformation():
    print "# BetaTurnTool18: Software identifying beta turns in an input protein structure (mmCIF/PDB) according to BetaTurnLib18 library"
    print "# Maxim Shapovalov, Slobodan Vucetic, Roland Dunbrack (C) 2018-19"
    print "# Tool version: 1.1.10"
    print "# License: BSD 3-Clause (free, open-source, redistributable and modifiable)"
    print "# Supported on Unix/Mac/Windows"
    print "# "
    print "# Detected operating system family: \'%s\'" % glob_operating_system_full
    print "# Running executable file: \'%s\'" % glob_fpath_script
    print "# biopython library version: \'%s\'" % Bio.__version__
    print "# DSSP executable file: \'%s\'" % glob_fPath_dssp_binary
    print "# "

def PrintProgramUsage():
    print "# "
    print "# **************"
    print "# The tool help:"
    print "# **************"
    print "# "
    print "# Arguments can be in any order, and provided in a short -i or long notations, i.e. --input."
    print "# "
    print "# -i, --input: specifies an input structure file in mmCIF or PDB format"
    print "#    The mmCIF file must have *.cif or *.mmcif (case-insensitive) file extension,"
    print "#    otherwise the input file is treated as PDB format."
    print "#    The PDB can be complete with annotation records like ones from RCSB PDB or"
    print "#    can be stripped only with ATOM records such as output from 3rd-party modeling software."
    print "#    Examples: -i abcd.cif   or --input myFavoriteInput/1234Z.Cif   or --pdb /home/user/Hemoglobin.CIF"
    print "#    Examples: -i abcd.mmcif or --input myFavoriteInput/1234Z.mmCif or --pdb /home/user/Hemoglobin.MMCIF"
    print "#    Examples: -i abcd.pdb   or --input myFavoriteInput/1234Z.Pdb   or --pdb /home/user/Hemoglobin.PDB"
    print "# "
    print "# OPTIONAL arguments:"
    print "# -------------------"
    print "# "
    print "# -o, --output: is the filename for output"
    print "#    Tool output can be directed to the screen and optionally to an output file. By default the screen output"
    print "#    comes with different comments and hints. The file output does not have them and is intended for easier"
    print "#    parsing and post-analysis. Please see --quiet option below, if no screen output is desired."
    print "#    Examples: -o ABCD_bTurns.out or --output /home/user/Enzyme_out.turns or -o myOutput/Hemoglobin_out.txt"
    print "# "
    print "# Three options controlling 3-10 helices"
    print "# ......................................"
    print "# "
    print "# Default (no additional argument needed): tool allows turns to be identified in all non-H (non-alpha-helical)"
    print "#    and non-E (non-extended-strand) residues as well as isolated 3-10 helices of a length 3 (DSSP code: GGG)."
    print "#    Isolated 3-10 helices are those not immediately adjacent to alpha-helical residues, which may be considered"
    print "#    part of the helix. GGGG and longer 3-10 helices are considered regular secondary structure and are not analyzed"
    print "#    for beta turns. Isolated G or GG are impossible with DSSP."
    print "# "
    print "# -noG, --exclude-all-3-10-helix: this flag prohibits any 3-10 helix (G) at the 2nd and 3rd residues"
    print "#    of a beta turn. In another words, isolated GGG (allowed by above Default) are now excluded. With"
    print "#    this flag, beta turns are only allowed in a classical definition of a loop. CGGGC are prohibited."
    print "# "
    print "# -allG, --include-all-3-10-helix: it allows the 2nd and 3rd beta-turn residues in any stretch of G of any"
    print "#    length and whether or not adjacent to alpha helices. HGGGH, HGGGC, HGGGGH, CGGGGGC, GGGGGG are all allowed."
    print "# "
    print "# "
    print "# -noOther, --exclude-other-group-from-turn-assignment: excludes Other group for beta-turn assignment. There are"
    print "#    18 beta-turn types in our beta-turn library, BetaTurnLib18. The tool calculates 18 distances between a sample"
    print "#    turn and 18 types and selects the first and second closest types. There is Other group for the samples that"
    print "#    are not within a pre-selected distance to any of 18. Other group is rare but a legitimate group of non-standard"
    print "#    turn conformations. The default allows assignment of Other to a input turn sample. With the above flag, the tool"
    print "#    can assign the closest type among the standard 18 types only disregarding how far away the sample to the closest"
    print "#    turn can be."
    print "# "
    print "# -Ca1Ca4 VALUE_IN_ANGSTROM, --Ca1Ca4-distance-cutoff: overrides the default cutoff value of 7.0 Angstroms for Ca(1)-Ca(4)"
    print "#    distance between Calpha atoms of the 1st and 4th residues of a beta turn. The standard definition of a beta turn"
    print "#    requires it to be <= 7.0 Angstroms. Any continuous stretch of four residues at most can be 11.4 A (3 x 3.8 A per"
    print "#    Calpha-Calpha distance across a single peptide bond. In beta sheets, the average Ca(1)-Ca(4) is over 10 Angstroms."
    print "#    The four-residue segments with about 9-Angstrom Ca(1)-Ca(4) are L-shaped with 3 extended residues and the forth one"
    print "#    hooking left or right. Structures at 8 Angstroms are shaped like beta turns but wider and shallower than those with"
    print "#    Ca-Ca distances less then 7 Angstroms. In some applications, it might be beneficial to relax the cutoff up to 8-8.5"
    print "#    Angstroms. The tool reports individual Ca(1)-Ca(4) distances for each detected beta turn in Ca1Ca4 output column."
    print "# "
    print "# "
    print "# These options control standard output and optional file output:"
    print "# ..............................................................."
    print "# "
    print "# --quiet: this flag does not permit any terminal output; it is intended for use with the optional file output and"
    print "#    is useful for batch processing using an external user script."
    print "# "
    print "# --no-comments: disables any comments in the terminal output starting with '# ', these comments give different hints"
    print "# on the current parameters used with short explanations. The optional file output never has any comments."
    print "# "
    print "# --no-table-format: disables output of detected beta turns in the table format both in the terminal output and"
    print "#    optional file output."
    print "# "
    print "# --no-seq-format: when present, both the terminal output and optional file output do NOT have aminoacid sequence"
    print "#    output aligned with 8-label DSSP secondary structure and identified one-letter beta-turn types as well as"
    print "#    encoded confidence levels for assigned types. By default, there is such output."
    print "# "
    print "# --yes-singleline-format: enables a single-line tab-delimited output of the sequence format. This option is useful"
    print "#    for a bulk batch processing and post-analysis where a single line is needed for each protein chain. Be default such"
    print "#    output is disabled."
    print "# "
    print "# -mode, --report-closest-mode-torsions: this flag enables output of modal 7 torsion angles in the table format for detected"
    print "#    turn types. The modal conformation is the most common geometry for a detected turn type. It is represented by a real,"
    print "#    reliable and high-electron density conformation taken from a real protein structure. These 18 conformations are reported"
    print "#    in our BetaTurnLib18 library. The modal conformations are useful for modeling. The 7 torsion angles are reported both for"
    print "#    the first closest type and the second closest types."
    print "# "
    print "# -medoid, --report-closest-medoid-torsions: the same as --report-closest-mode-torsions but reports 7 torsion angles for"
    print "#    a medoid beta-turn conformation. Again, these conformations are real and reliable and also included in our BetaTurnLib18"
    print "#    library. Medoids represent the center of each of 18 beta-turn type clusters. The medoids are useful when deciding to which"
    print "#    turn type an input beta-turn sample should be assigned."
    print "# "
    print "# "
    print "# Other options:"
    print "# .............."
    print "# "
    print "# -everything, --print-any-4-res-segments: BE CAREFUL using it! When this flag is present, the program reports all continuous"
    print "#    four-residue segments without enforcing any constraints like Ca(1)-Ca(4) or DSSP secondary structure. As long as four"
    print "#    residues are standard amino acids, have coordinates and are continuous, such 4-residue segment is reported and closest"
    print "#    beta turn is assigned. This argument is useful to use our tool to calculate torsion angles for stretches of four residues"
    print "#    and not for beta-turn detection."
    print "# "
    print "# --yes-2nd-turn-alternative-for-other-group: for turns assigned with Other group, i.e. a legitimate group of non-standard turn"
    print "#    conformations, the tool will also report the 2nd alternative from the 18 turn types. BE CAREFUL in using the 2nd alternative"
    print "#    when confidence in the second alternative is low relative to Other group."
    print "# "
    print "# "
    print "# --library is a beta-turn library file with all beta-turn type defintions and nomenclature."
    print "#    The default filename is \'" + glob_default_bturn_library_filename + "\'."
    print "#    It is included in BetaTurnLib18 directory of this tool parent directory."
    print "#    Example: --library \home\user\files\some_other_beta_turn_library_file"
    print "# "
    print "# --dssp is a binary file of dssp program."
    print "#    The default is dssp_unix, dssp_mac and dssp_win for Unix, Mac and Windows respectively."
    print "#    The defaults and alternatives are stored in DSSP directory of this tool parent directory."
    print "#    If default binary proves to be incompatible with your operating system, you can override it with"
    print "#    the included alternatives, downloading or compiling your own DSSP."
    print "#    Example: --dssp dssp_mac_most_compatible_apr_2000 or --dssp /home/user/tools/dssp_mac_2.0.4"
    print "# "
    print "# -h, --help: prints this help."
    print "# "
    print "# "
    print "# Usage examples:"
    print "# ==============="
    print "# "
    print "# python2 BetaTurnTool18.py2"
    print "# python2.7 /bin/BetaTurnTool18.py2 --input 4qlp.cif"
    print "# ./BetaTurnTool18.py2 -i ../files/4qlp.pdb --output 4qlp.bturns --quiet"
    print "# /tools/BetaTurnTool18.py2 -i Hemoglobin.mmCIF -noG -noOther -Ca1Ca4 8.250 --no-comments"
    print "# BetaTurnTool18.py2 -i ./temp/3J9P.CIF -o 3J9P_turns.txt -allG --no-seq-format --dssp dssp_unix_i386_2.0.4"
    print "# BetaTurnTool18.py2 -i 4qlp.pdb --no-comments -no-table-format --no-seq-format -yes-singleline-format"
    print "# BetaTurnTool18.py2 -i /mnt/data/4qlp.CIF -everything"
    print "# BetaTurnTool18.py2 -i 4qlp.CIF --library new_bturn.lib"

def Extend_bTurnLibListOfDict_WithAdditInfo(glob_bTurnLibListOfDict):
    _total_type_size_with_Other = 0
    for _entry in glob_bTurnLibListOfDict:
        _total_type_size_with_Other += int(_entry['cluster_size'])

    #before 'a'
    _one_letter_int = 96
    for _entry in glob_bTurnLibListOfDict:
        _entry['percentage'] = float(_entry['cluster_size']) / _total_type_size_with_Other * 100.
        _one_letter_int += 1
        if _entry['no_by_size'] != 'Other':
            _entry['one_letter'] = chr(_one_letter_int)
        else:
            _entry['one_letter'] = 'z'
            _entry['no_by_size'] = _one_letter_int - 96
            _one_letter_int -= 1

def Print_bTurns_Information():
    print '# '
    print "# BetaTurnLib file: \'%s\'" % glob_fPath_BetaTurnLib
    print "# Library version: %s" % glob_BetaTurnLib_version
    print '# '
    print '# Beta turn types:'
    print '# ================'
    print '# '
    print "# int\tfreq\tcount\ttype\tprev_name\tletter"
    print '# '

    for _entry in glob_bTurnLibListOfDict:
        print '# %s\t%.2f\t%s\t%s\t%-13s\t%s' % (_entry['no_by_size'], _entry['percentage'], _entry['cluster_size'], _entry['bturn_name'], _entry['prev_name'], _entry['one_letter'])

    print '# '

def Print_bturn_type_confidence_Information():
    print '# '
    print '# Confidence one-letter integer values used in the sequence format output:'
    print '# ========================================================================='
    print '# '
    print "# one_letter   confid_range   border_case_flag"
    print '# '
    for __i in range(10):
        if __i != 9:
            __ending_symbol = ')'
        else:
            __ending_symbol = ']'

        __upper_limit = (__i + 1) * 0.1

        if __upper_limit <= (glob_border_confidence_value + 1e-9):
            __border_case = '+'
        else:
            __border_case = '.'

        print '# %10i   [ %3.1f, %3.1f %s   %s' % (__i, __i * 0.1, __upper_limit, __ending_symbol, __border_case)

    print '# '
    print '# Border confidence is %.1f' % glob_border_confidence_value
    print '# '
    print '# Beta-turn type determinations with confidence >= %3.1f are confident and are NOT border cases (\'.\').' % (glob_border_confidence_value)
    print '#                                                      A single identified type is enough.'
    print '# '
    print '# Beta-turn type determinations with confidence <  %3.1f are weaker identifications (e.g., the turn might' % (glob_border_confidence_value)
    print '#                                                      be half way between two neighboring turn types),'
    print '#                                                      and are designated border cases (\'+\'). Two'
    print '#                                                      predicted types are required.'
    print '# '

if __name__ == '__main__':
    main()
